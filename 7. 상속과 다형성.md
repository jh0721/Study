**객체포인터변수**

객체의 주소값을 저장하는 포인터 변수이며 상속받은 derived 클래스까지 가르킬 수 있다. 이때 생성된 객체는 base class의 객체이다. 이 객체는 포인터형에 해당하는 클래스에 정의된 멤버에만 접근이 가능하다. 가상함수를 통해 실제 가르키는 포인터의 객체 멤버에 접근할 수 있다

~~~c++
Base *t = new Derived();
~~~



**함수 오버라이딩 **

base클래스의 함수를 derived클래스에서 재정의 하여 사용한다. derived객체에서 함수를 호출할 경우 오버라이딩된 함수가 호출된다. 매개변수의 자료형과 개수가 다를경우는 오버로딩이다. base class의 함수를 호출 할 경우 base:: 를 사용하여 접근한다

~~~c++
class Base
{
private:
	int num;
public:
	Base():num(0){};
	~Base(){}

	void showInfo()
	{
		print("num: ");
		print(num);
	}
};

class Derived:public Base
{
private:
	int value;
public:
	Derived():value(0) {};
	
	// 오버라이딩
	void showInfo()
	{
		// base class 함수 호출
		Base::showInfo();
		print("value: ");
		print(value);
	}
};

int main() {

	Derived d;
	d.showInfo();

	return 0;

}
~~~



**가상함수**

객체 포인터 변수: 객체의 주소값을 저장하는 포인터 변수이며 상속받은 derived class를 가르킬 수 있다. 

```c++
// b 포인터는 derived class를 가르키지만 실제 저장된 포인터 타입은 Base class 이다. 따라서 Base class의 멤버만 접근이 가능하며, 가상함수를 통해 이를 해결 할 수있다
Base *b = new Derived();
```



virtual을 선언하여 사용하며 포인터의 자료형을 기반으로 함수를 호출하지 않고, 포인터 변수가 실제 가르키는 객체를 참조하여 함수를 호출한다. base class의 함수를 virtual로 선언하면 derived class의 함수도 자동으로 virtual 함수가 된다

~~~c++
class Base
{
public:
	Base(){};
	virtual ~Base(){};
    // 가상함수 선언
	virtual void showInfo() const
	{
		print("base class ");

	}
};

class Derived:public Base
{
public:
	virtual void showInfo() const
	{
		Base::showInfo();
		print("derived class ");

	}
};

int main() {

	Derived d;
	Base *b = &d;
	
    // 가상함수이므로 d객체의 함수가 호출된다
	b->showInfo();
	print("");
	d.showInfo();
    
	return 0;

}
~~~



**가상소멸자**



**순수 가상함수**



**다형성**

